<!DOCTYPE html>
<html>

<head>
	<title>WebRTC Sender</title>
</head>

<body>
	<!-- <video id="localVideo" autoplay playsinline></video> -->
	<script src="./socketIO.min.js"></script>
	<script>

		const userId = Math.random().toString(36).replace('0.', '');
		const socket = io('http://localhost:5001');
		/* const localVideo = document.getElementById('localVideo'); */
		const config = {
        iceServers: [
            { urls: 'stun:localhost:3478' }
        ]
    };
		let localStream;
		const peerConnections = {}; // Store peer connections with unique identifiers
		const pendingCandidates = {}; // Store pending candidates for each peer
		

		async function init() {
			try {
				localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
				/* localVideo.srcObject = localStream; */
				console.log('Local stream obtained');

				socket.on('message', handleSocketMessage);
				socket.on('disconnect', handleSocketDisconnect);
				socket.emit('message', { type: 'status', online: true, camera: true, username: userId });

			} catch (error) {
				console.error('Error accessing media devices.', error);
				alert('Error accessing media devices: ' + error.message);
				socket.emit('message', { type: 'status', online: true, camera: false, username: userId });
			}
		}

		function createPeerConnection(peerId, sendTo) {
			try {
				
			
			const peerConnection = new RTCPeerConnection(config);
			console.log('PeerConnection created for peer:', peerId);

			localStream.getTracks().forEach(track => {
				peerConnection.addTrack(track, localStream);
				console.log('Added local track for peer:', peerId, track);
			});

			peerConnection.onicecandidate = event => {
				if (event.candidate) {
					console.log('ICE candidate generated for peer:', peerId, event.candidate);
					socket.emit('message', { type: 'candidate', candidate: event.candidate, peerId: peerId, username: userId, to: sendTo });
				}
			};

			peerConnection.onconnectionstatechange = () => {
				if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
					handlePeerDisconnect(peerId);
				}
			};

			peerConnections[peerId] = peerConnection;
			pendingCandidates[peerId] = [];
		} catch (error) {
			socket.emit('message', { type: 'error', username: userId, msg: error });
			}

			return peerConnection;
		}

		function createOffer(peerConnection, message) {
			try {
				
			
			console.log('******  Creating Offer: ', message.sid)
			peerConnection.createOffer()
				.then(offer => peerConnection.setLocalDescription(offer))
				.then(() => {
					// Send the offer to the remote peer
					socket.emit('message', { type: 'offer', offer: peerConnection.localDescription, to: message.username, username: userId });
					console.log('Offer Sent')
				})
				.catch(error => {
					console.error('Error creating offer:', error);
				});
			} catch (error) {
				socket.emit('message', { type: 'error', username: userId, msg: error });
			}
		}

		async function handleSocketMessage(message) {
			try {
				
			
			console.log('This server ID: ', userId)
			console.log('Received message:', message);

			if (userId === message.username) return
			
			const peerId = message.peerId;
			console.log("to: ", message.to)
			console.log(message.sid)
			console.log(peerId)
			console.log(pendingCandidates)

			if (message.type === 'offer') {
				const peerConnection = createPeerConnection(peerId, message.username);
				await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
				console.log('Offer set as remote description for peer:', peerId, message.offer);
				const answer = await peerConnection.createAnswer();
				await peerConnection.setLocalDescription(answer);
				console.log('Answer created and set as local description for peer:', peerId, answer);
				socket.emit('message', { type: 'answer', answer: answer, peerId: peerId, username: userId, to: message.username });

				// Add any pending ICE candidates
				pendingCandidates[peerId].forEach(async candidate => {
					await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
					console.log('Added pending ICE candidate for peer:', peerId, candidate);
				});
				if (!pendingCandidates[peerId]) pendingCandidates[peerId] = [];
			} else if (message.type === 'answer') {
				const peerConnection = peerConnections[peerId];
				if (peerConnection) {
					await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
					console.log('Answer set as remote description for peer:', peerId, message.answer);
				}
			} else if (message.type === 'candidate') {
				const peerConnection = peerConnections[peerId];
				if (peerConnection && peerConnection.remoteDescription) {
					try {
						await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
						console.log('Added ICE candidate for peer:', peerId, message.candidate);
					} catch (error) {
						console.error('Error adding ICE candidate for peer:', peerId, error);
					}
				} else {
					// Queue candidate if remote description is not set yet
					if (pendingCandidates[peerId]) pendingCandidates[peerId].push(message.candidate);
					console.log('Queued ICE candidate for peer:', peerId, message.candidate);
				}
			} else if (message.type === 'connection') {
				console.log('Connection Request', message)
				handlePeerDisconnect(peerId);
				console.log('Handle connection')
				const peerConnection = createPeerConnection(peerId);
				createOffer(peerConnection, message);
			} else if (message.type === 'disconnected') {
				console.log('Handle disconnected')
				handlePeerDisconnect(peerId);
			}
		} catch (error) {
			socket.emit('message', { type: 'error', username: userId, msg: error });
			}
		}

		function handleSocketDisconnect() {
			console.log('Socket disconnected');
			Object.keys(peerConnections).forEach(peerId => {
				handlePeerDisconnect(peerId);
			});
		}

		function handlePeerDisconnect(peerId) {
			const peerConnection = peerConnections[peerId];
			if (!peerConnection) return
			console.log('Peer disconnected, cleaning up for peer:', peerId);
			if (peerConnection) {
				peerConnection.close();
				delete peerConnections[peerId];
			}
			if (pendingCandidates[peerId]) {
				delete pendingCandidates[peerId];
			}
		}

		function stopStream() {
			if (localStream) {
				let tracks = localStream.getTracks();
				tracks.forEach(track => track.stop());
				localStream = null;
				console.log('Stream stopped');
			}


		}

		navigator.mediaDevices.addEventListener('devicechange', async () => {
			console.log('Media devices changed');

			// Check if the current camera is still available
			let devices = await navigator.mediaDevices.enumerateDevices();
			let videoInputDevices = devices.filter(device => device.kind === 'videoinput');

			if (videoInputDevices.length === 0) {
				// No video input devices available
				console.log('No video input devices found');
				socket.emit('message', { type: 'status', online: true, camera: false, username: userId });
				stopStream();
			} else if (!localStream) {
				// Restart the stream if it was previously stopped
				console.log('Video input device reconnected');
				init();
			}
		});

		init();
	</script>
</body>

</html>